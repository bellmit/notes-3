一共有 8 种排序算法

1. 冒泡排序（稳定）
2. 选择排序
3. 插入排序（稳定）
4. 快速排序
5. 归并排序（稳定）
6. 基数排序（稳定）
7. 希尔排序
8. 堆排序

# 一、冒泡排序

思想：把大的元素往后移动，相邻的两个元素进行比较交换。

所以你不会把两个相同的元素进行交换吧？即使两个元素没有相邻，经过交换也不会改变它俩的位置，所以相同元素经过排序后顺序没有发生改变。

所以 冒泡排序 是稳定的。

时间复杂度：O(n²)

# 二、选择排序

思想：每次从剩余的数组中选出最小的一个元素，放在未排序数组的头部。

举个例子：[5, 8, 5, 2, 9]，第一次选择出 2，会与第一个 5 进行交换，变为 [2, 8, 5, 5, 9]，此时两个 5 的顺序就发生了变化。

所以 选择排序 不是稳定的。

时间复杂度：O(n²)

# 三、插入排序

思想：假定数组的前 N 个元素已经是排好序的，取已经排好序的数组后第一个待排序的元素，从已经排好序的数组的尾部开始比较交换，如果相等的话，肯定不会进行交换了，直接放在相等元素的后面。

因为元素的获取是从头到尾的，相等的话，就不会进行交换了，所以 插入排序 是稳定的。

时间复杂度：O(n²)

# 四、快速排序

思想：选择一个 key，先进行分区（把小于这个值的元素放在左边，大于这个值的元素放在右边），直到 left == right。

如：[5, 3, 4, 3, 6, 7, 8, 9]，key 选择为 5，第一遍分区之后就变为 [3, 3, 4, 5, 6, 7, 8, 9]，此时 3 这个相同元素的顺序就被打乱了。

所以 快速排序 是不稳定的。

时间复杂度：O(nlogn)

# 五、归并排序

思想：将一个数组进行平分，为一个小数组，一直平分到只有一个元素，最后，再进行合并（合并两个有序的数组）。

两个数字相等的时候，我们把前面的数字放在合并数组的前面，这样就破坏不了顺序了。

所以 归并排序 是稳定的。

时间复杂度：O(nlogn)
