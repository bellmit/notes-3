# 一、简介

CMS垃圾收集器是一款用于**老年代**的，使用复制-清除-整理算法的垃圾收集器。

记住：下面说的所有东西都是在老年代中进行的。

对于 CMS，GC ROOTS 包含：statck、register、gloabl object 和 **年轻代**。

> 要注意：CMS 是一个老年代的收集器，不是整个堆的垃圾收集器，既然只收集老年代，它必须把当前处于非收集区域的年轻代算作是 GC ROOTS。这跟一般的年轻代 GC 时要把老年代的 Remembered Set 部分算作 GC ROOTS 的道理一样，只不过 HotSpot 没有用 card table 来记录 young -> old 引用，所以就干脆扫描整个年轻代作为 GC ROOTS。

# 二、GC阶段

## 1、初始化标记（STW）

暂停应用程序线程，遍历 GC ROOTS 直接可达的对象并将其压入**标记栈**（mark-stack），标记完之后恢复应用程序线程。

此时，GC ROOTS 直接可达的对象被标记为灰色，其它所有对象默认为白色。

> 在 CMS initial mark 的上下文里，根集合并不包括 young gen 而是只有 stack、register、globals object 这些常规的。这是因为在接下来的 CMS concurrent mark 阶段 CMS 会顺着初始的根集合把 young gen 里的活对象都遍历了。所以从 CMS initial mark + concurrent mark 结合在一起的角度看，young gen 仍然是根集合的一部分（因为被扫描但不被收集）。

## 2、并发标记

虚拟机分配出若干GC线程去进行并发标记，标记那些从 GC Roots 最终可达的对象。

**过程**：弹出标记栈中的对象，递归标记其直接引用的子对象，标记的同时把子对象压入到栈中，重复弹出、压入。。。**直至标记栈为空**。

并发标记结束后，对象都是黑色和白色了，其中有些白色是并发标记过程中新插入的引用关系，这部分对象不能被清理掉。

**问题**：如何将这些新插入的引用关系给找出来呢？

这里就会牵扯出 CMS 增量更新的概念，所谓增量更新就是把并发标记期间引用的变化记录下来，那么它怎么记录下来呢？使用的技术就是通过写屏障（write barrier，可以把它理解为是对引用对象赋值的环切）将引用关系记录下来。

引用[R大的描述](https://hllvm-group.iteye.com/group/topic/44529)：

> Incremental update 的 write barrier 会拦截所有新插入的引用关系，并且按需要记录新的引用关系。常见实现会判断例如：a.foo = b 那么 a 是否是黑色对象而 b 是否是白色对象，也有完全不做过滤的变种。CMS 具体使用的 write barrier 是无条件的，跟 HotSpot VM 除 G1 外的其它 GC 的 card marking 基本一样。



## 3、重新标记（STW）TODO

重新标记会从根对象（GC ROOTS）开始扫描，扫描**所有对象**，但是已经标记的对象是不会再遍历一次，

重新从当前的 GC ROOTS 和指针更新的区域出发（mod-union table）再进行一次标记，所以这个过程被叫作重新标记。需要注意的是：**已经标记的对象是不会再遍历一次**，标记线程识别对象在并发阶段已经标记过了，就会跳过该对象。所以重新标记只会遍历那些新增没有标记过的活动对象和其间有指针更新的活动对象，如果指针更新频繁，重新标记很有可能会遍历新生代中的大部分甚至全部对象。所以如果重新标记阶段很慢，可以启动一次YGC，来减少并发标记的工作量减少其停顿时间。

## 4、并发清除

重新标记结束后，应用程序继续运行，此时分出一个处理器去进行垃圾回收工作。

老年代的对象通常是存活时间长，回收比例低，所以采用的回收算法是**标记-清除**。这个阶段 GC 回收线程是遍历整个老年代，遇到没有被标记的对象（垃圾）就清空掉相应的内存块，并加入可分配列表。遇到被标记的对象保持原来的位置不动，只是重置其标记位，用于下一次GC。

## 5、并发重置

Oracle 官方文档中描述这个阶段的工作是：重新调整堆的大小，并为下一次GC做好数据结构支持，比如重置卡表的标位，具体细节有待考证。

# 三、知识点

## 1、三色标记

实际上三色标记中的色并不只是颜色，而是我们对它的一种叫法，但是实际上他不会用red white 这种东西来定义，而是用例如 0,1,2 这样的东西来定义不同的对象。

其实三色标记就是我们 CMS 在扫描过程中对对象的一种定义。那么具体的定义如下：

- 黑色：1、对象本身及其引用都被扫描过；2、黑色不能直接指向白色；3、不能被回收
- 灰色：1、对象本身被扫描；2、还存在至少一个引用没有被扫描
- 白色：1、没有被扫描；2、扫描结束后被回收

**标记过程**：

1. 刚开始，所有对象都是白色，没有被扫描
2. 将 GC ROOTS 直接关联的对象标记为灰色
3. 遍历灰色对象的引用，遍历完后，灰色对象本省置为黑色，引用置为灰色
4. 重复步骤3，直到所有的灰色对象被遍历完
5. 结束后，只有黑色和白色对象，黑色存活，白色被回收

这个过程的正确执行的前提是没有其它线程改变对象的引用，但是在 CMS 并发标记的过程中，用户线程仍在运行，因为就会出现漏标或错标。

##### **错标**

如图：假设正在遍历对象B，而此时用户线程执行了 `A.B = null`，切断了 A 到 B 的引用。

![image-20210706173845547](http://snail-resources.oss-cn-beijing.aliyuncs.com/1625564326.575464Yah2dvO8xg.png)

本来执行完`A.B = null`后，B、D、E 都可以被回收，但是由于 B 已经变为灰色了，它仍会被当做存活对象，继续遍历下去。
最终的结果就是本轮GC不会回收B、D、E，留到下次GC时回收，这就是是浮动垃圾。

**漏标**

如图：假设正在遍历对象B，而此时用户线程执行了 `B.D = null`，切断了 B 到 D 的引用，然后又建立了 A 到 D 的引用。

![image-20210706174131813](http://snail-resources.oss-cn-beijing.aliyuncs.com/1625564492.798998H6Tc2BV34t.png)

由于 A 已经被遍历过了，而 B 又与 D 断开引用了，所以本次标记结束后，D 对象一直是白色，最终是要被回收掉的，如果被回收了，就发生错误了。

可以看到漏标的结果比错标严重的多，浮动垃圾可以下次GC清理，而把不该回收的对象回收掉，将会造成程序运行错误。

漏标只有同时满足以下两个条件才会发生：

1. 灰色对象断开了白色对象的引用（直接或间接的引用）；即灰色对象原来成员变量的引用发生了变化。
2. 黑色对象重新引用了该白色对象；即黑色对象成员变量增加了新的引用。

只要打破其中一个条件就可以解决漏标的问题，CMS 选择打破第二个条件，G1 选择打破第一个条件。

在并发标记和重新标记的过程中都会使用三色标记。

## 2、卡表

**1）、为什么需要卡表？**

YGC 只扫描年轻代内的对象，如果一个对象 A 没有被年轻代中的其它对象引用，而是被老年代中的一个对象引用，此时对象 A 则经过标记后，会一直是白色，最后将被被清理掉，导致程序致命错误。

**2）、如何解决这个问题？**

1. 扫描老年代，此时就等于扫描整个堆了
2. 使用卡表

**3）、卡表的结构**：通常使用 byte 数组表示，byte 的值只能取 [0,1] 这两种，那么 0 和 1 分别表示什么呢？

CMS 垃圾处理器，将老年代分成一个个大小为 512KB 的卡（card），byte 数组上的一个元素表示一个卡，如果这个卡上只要有一个对象引用了年轻代的对象，那么这个卡就是脏卡（dirty card）。

**4）、卡表怎么用呢？**

有了卡表之后， YGC 时想知道老年代哪些对象引用了年轻代的对象，不需要扫描整个老年代了，只需要遍历卡表，扫描脏卡表示的老年代内存区域即可知道有哪些对象引用了年轻代的对象，这样，就避免了年轻代的对象被漏标。

YGC 时会把脏卡中的对象作为 GC ROOTS。

**5）、卡表的元素什么时候被赋值呢？**

我理解的是在对象被引用的时候，有一个 AOP 的操作，元素被赋值的时候，判断是不是老年代的对象引用的年轻代，如果是就更新卡表上的元素。

YGC 结束后会清空卡表，然后重新进行赋值。

**6）、总结**

卡表其实是用来支持 YGC 的，但是 CMS 也需要卡表中的数据，引出了mod-union table，后面会将说明。

## 2、Concurrent Mode Failure

如果 CMS 在清理掉垃圾对象之前，老年代中没有足够的空间存放新产生的对象，就会出现 Concurrent Mode Failure。

# 四、缺点

1. **内存碎片**（原因是采用了标记-清除算法）
2. **对 CPU 资源敏感**（原因是并发时和用户线程一起抢占 CPU）
3. **浮动垃圾**：在并发标记阶段产生了新垃圾不会被及时回收，而是只能等到下一次GC

然后我产生了一个疑问：既然重新标记可以修正并发标记阶段的变动，那么为何还有浮动垃圾问题？

由于标记阶段是从 GC Roots 开始标记可达对象，那么在并发标记阶段可能产生两种变动：

1. 本来可达的对象，变得不可达了。（浮动垃圾）
2. 本来不可达的内存，变得可达了。

浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢？也许是由可达变为不可达这样的变化需要重新从 GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。

# 四、日志解读

```
# 年轻代 GC，使用 ParNew
0.210 [GC (Allocation Failure) [ParNew: 279616K->34942K(314560K), 0.0246537 secs] 279616K->79707K(1013632K), 0.0246999 secs] [Times: user=0.06 sys=0.09, real=0.03 secs]

# 老年代 GC

# 初始计标记，速度很快只用了3.1毫秒
# 372071K：老年代的使用量；699072K：老年代的总容量；413038K：堆的使用量；1013632K：整个堆的容量；0.0003105 secs：耗时
0.526: [GC (CMS Initial Mark) [1 CMS-initial-mark: 372071K(699072K)] 413038K(1013632K), 0.0003105 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动并发标记步骤
0.526: [CMS-concurrent-mark-start]
0.529: [CMS-concurrent-mark: 0.003/0.003 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]

# 启动预清理步骤，这个阶段会尽可能在重新标记前，处理掉一些在并发标记阶段发生变化的引用关系，从而降低重新标记阶段的停顿时间
# 清理 Eden 区中发生变化的引用（dirty card）
0.529: [CMS-concurrent-preclean-start]
0.530: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动可中断的预清理，这个阶段主要处理 from 和 to 区域对象引用 old gen 的变化，同样也会继续处理 dirty card 的对象引用。这个阶段默认设置的时间是5s，如果执行逻辑超过5s，会自动终止这个阶段，或者当eden区使用内存值小于 CMSScheduleRemarkEdenPenetration，默认 50% 时，也会退出这个阶段。
0.530: [CMS-concurrent-abortable-preclean-start]
0.844: [CMS-concurrent-abortable-preclean: 0.006/0.315 secs] [Times: user=1.34 sys=0.12, real=0.31 secs]

# 重新标记
# 35015K：年轻代当前的使用量；314560K：年轻代的总容量；
0.845: [GC (CMS Final Remark) [YG occupancy: 35015 K (314560 K)]
# Rescan：进行重新标记，耗时 0.0004597 secs
0.845: [Rescan (parallel) , 0.0004597 secs]
# 处理弱引用
0.845: [weak refs processing, 0.0000086 secs]
# 卸载 class
0.845: [class unloading, 0.0004208 secs]
# 清理类级元数据和内部化字符串的符号和字符串表
0.845: [scrub symbol table, 0.0004006 secs]
0.846: [scrub string table, 0.0001479 secs]
# 老年代的使用情况及堆的使用情况
[1 CMS-remark: 677072K(699072K)] 712088K(1013632K), 0.0014893 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动并发清除，任务是清除那些没有标记的无用对象并回收内存
0.846: [CMS-concurrent-sweep-start]
0.847: [CMS-concurrent-sweep: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]

# 启动并发重置，作用是重新设置CMS算法内部的数据结构
0.847: [CMS-concurrent-reset-start]
0.849: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
```









