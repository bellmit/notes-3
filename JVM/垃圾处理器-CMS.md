# 一、简介

CMS垃圾收集器是一款用于**老年代**的，使用复制-清除-整理算法的垃圾收集器。

记住：下面说的所有东西都是在老年代中进行的。

对于 CMS，GC ROOTS 包含：statck、register、gloabl object 和 年轻代。

> 要注意：CMS 是一个 old gen collector（不是 whole heap collector）。既然只收集 old gen，它必须把当前处于非收集区域的 young gen 算作是 root。这跟一般的 young GC 时要把 old gen 的 remembered set 部分算作 root 的道理一样，只不过 HotSpot 没有用 card table 来记录 young -> old 引用，所以就干脆扫描整个 young gen 作为 root。

# 二、GC阶段

## 1、初始化标记（STW）

暂停应用程序线程，遍历 GC ROOTS 直接可达的对象并将其压入**标记栈**（mark-stack），标记完之后恢复应用程序线程。

此时，GC ROOTS 直接可达的对象被标记为灰色，其它所有对象默认为白色。

## 2、并发标记

虚拟机分配出若干GC线程去进行并发标记，标记哪些从 GC Roots 可达的对象。

**过程**：弹出标记栈中的对象，递归标记其直接引用的子对象，标记的同时把子对象压入到栈中，重复弹出、压入。。。直至标记栈为空。

并发标记结束后，会立马进入重新标记阶段，此时需要 STW，STW 之前，所有的对象引用都要经过 Write Barrier，确保 STW 之前所有的对象都能统计到。









## 3、重新标记（STW）

重新标记可以理解成一个同步刷新对象间引用的操作，整个过程是 STW。在并发标记其间，应用程序不断变更对象引用，此时的 GC ROOTS 有可能会发生变化，这个时候需要同步更新这个增量变化。于是重新从当前的 GC ROOTS 和指针更新的区域出发（mod-union table）再进行一次标记，所以这个过程被叫作重新标记。需要注意的是：**已经标记的对象是不会再遍历一次**，标记线程识别对象在并发阶段已经标记过了，就会跳过该对象。所以重新标记只会遍历那些新增没有标记过的活动对象和其间有指针更新的活动对象，如果指针更新频繁，重新标记很有可能会遍历新生代中的大部分甚至全部对象。所以如果重新标记阶段很慢，可以启动一次YGC，来减少并发标记的工作量减少其停顿时间。

## 4、并发清除

重新标记结束后，应用程序继续运行，此时分出一个处理器去进行垃圾回收工作。

老年代的对象通常是存活时间长，回收比例低，所以采用的回收算法是**标记-清除**。这个阶段 GC 回收线程是遍历整个老年代，遇到没有被标记的对象（垃圾）就清空掉相应的内存块，并加入可分配列表。遇到被标记的对象保持原来的位置不动，只是重置其标记位，用于下一次GC。

## 5、并发重置

Oracle 官方文档中描述这个阶段的工作是：重新调整堆的大小，并为下一次GC做好数据结构支持，比如重置卡表的标位，具体细节有待考证。

# 三、知识点

## 1、卡表

CMS 中一个与 YGC 相关并十分重要的数据结构是：**卡表（Card Table）**。之所以出现卡表这样的一个数据结构是因为：YGC 时为了标记活动标记对象除了遍历 GC ROOTS 之外，别忘了老年代里也可能会引用新生代对象。所以正常来说还要扫描一次老年代，如果是扫描整个老年代这将会随着堆的增大变得越来越慢，特别是现在内存都越来越大了，所以为了提升性能就引入卡表。

**卡表提升性能的原理**：逻辑上把老年代内存分成一个个大小相等的卡片（Card，论文中提到适合大小是128个字节），然后对每个卡片准备一个与其对应的标记位，并将这些位集中起管理就好像一个表格（mark table）一样，当改写对象引用是从老年代指向新生代时，在老年代对应的卡片标记位上设置标志位即可，通常这样的卡片我们称之为 Dirty Card。这项操作可以通过上面的提到的 Write Barrier 来实现，这样就算对象跨多张卡片也不会有什么问题。卡表通常是用 byte 数组实现的，byte 的值只能取 [0,1] 这两种。所以 btye[i] = 1 就表示第 i + 1 卡片所在内存上有指向新生代引用的老年代对象，这时只要遍历这个卡片上的对象即可。如果每个 card 大小的是128字节（1024位），那卡表就只占整个老年代的 1/1024 之一。所以遍历卡表的时间会远比遍历整个老年代快得多！这其中背后思想就是典型以**空间换时间**的思路，这种思路在 G1 中也有体现，只不其对应的数据是 remember set 而已。

## 2、Concurrent Mode Failure

如果 CMS 在清理掉垃圾对象之前，老年代中没有足够的空间存放新产生的对象，就会出现 Concurrent Mode Failure。



4、三色标记

实际上三色标记中的色并不只是颜色，而是我们对它的一种叫法，但是实际上他不会用red white 这种东西来定义，而是用例如 0,1,2 这样的东西来定义不同的对象。

其实三色标记就是我们 CMS 在扫描过程中对对象的一种定义。那么具体的定义如下：

- 黑色：1、对象本身及其引用都被扫描过；2、黑色不能直接指向白色；3、不能被回收
- 灰色：1、对象本身被扫描；2、还存在至少一个引用没有被扫描
- 白色：1、没有被扫描；2、扫描结束后被回收

标记过程：

1. 刚开始，所有对象都是白色，没有被扫描
2. 将 GC ROOTS 直接关联的对象标记为灰色
3. 遍历灰色对象的引用，遍历完后，灰色对象本省置为黑色，引用置为灰色
4. 重复步骤3，直到所有的灰色对象被遍历完
5. 结束后，只有黑色和白色对象，黑色存活，白色被回收

这个过程的正确执行的前提是没有其它线程改变对象的引用，但是在 CMS 并发标记的过程中，用户线程仍在运行，因为就会出现漏标或错标。

**漏标**

如图：假设正在遍历对象B，而此时用户线程执行了 `A.B = null`，切断了 A 到 B 的引用。

![image-20210706173845547](http://snail-resources.oss-cn-beijing.aliyuncs.com/1625564326.575464Yah2dvO8xg.png)

本来执行完`A.B = null`后，B、D、E 都可以被回收，但是由于 B 已经变为灰色了，它仍会被当做存活对象，继续遍历下去。
最终的结果就是本轮GC不会回收B、D、E，留到下次GC时回收，这就是是浮动垃圾。

**错标**

如图：假设正在遍历对象B，而此时用户线程执行了 `B.D = null`，切断了 B 到 D 的引用，然后又建立了 A 到 D 的引用。 

![image-20210706174131813](http://snail-resources.oss-cn-beijing.aliyuncs.com/1625564492.798998H6Tc2BV34t.png)

由于 A 已经被遍历过了，而 B 又与 D 断开引用了，所以本次标记结束后，D 对象一直是白色，最终是要被回收掉的，如果被回收了，就发生错误了。

可以看到错标的结果比漏表严重的多，浮动垃圾可以下次GC清理，而把不该回收的对象回收掉，将会造成程序运行错误。

错标只有同时满足一下两个条件才会发生：

1. 灰色对象 断开了 白色对象的引用（直接或间接的引用）；即灰色对象 原来成员变量的引用 发生了变化。
2. 黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。

只要打破其中一个条件就可以解决错标的问题，CMS 选择打破第二个条件，G1 选择打破第一个条件。

5、增量更新

增量更新就是为了解决**错标**的情况。

当黑色指向白色的引用被建立时，就将这个新的引用关系记录下来，等扫描结束后，再以这些记录中的黑色对象为根，重新扫描一次。相当于黑色对象一旦建立了指向白色对象的引用，就会变为灰色对象。

增量更新的截止条件？并发标记什么时候结束？



# 四、缺点

1. **内存碎片**（原因是采用了标记-清除算法）
2. **对 CPU 资源敏感**（原因是并发时和用户线程一起抢占 CPU）
3. **浮动垃圾**：在并发标记阶段产生了新垃圾不会被及时回收，而是只能等到下一次GC

然后我产生了一个疑问：既然重新标记可以修正并发标记阶段的变动，那么为何还有浮动垃圾问题？

由于标记阶段是从 GC Roots 开始标记可达对象，那么在并发标记阶段可能产生两种变动：

1. 本来可达的对象，变得不可达了。（浮动垃圾）
2. 本来不可达的内存，变得可达了。

浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢？也许是由可达变为不可达这样的变化需要重新从 GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。

# 四、日志解读

```
# 年轻代 GC，使用 ParNew
0.210 [GC (Allocation Failure) [ParNew: 279616K->34942K(314560K), 0.0246537 secs] 279616K->79707K(1013632K), 0.0246999 secs] [Times: user=0.06 sys=0.09, real=0.03 secs]

# 老年代 GC

# 初始计标记，速度很快只用了3.1毫秒
# 372071K：老年代的使用量；699072K：老年代的总容量；413038K：堆的使用量；1013632K：整个堆的容量；0.0003105 secs：耗时
0.526: [GC (CMS Initial Mark) [1 CMS-initial-mark: 372071K(699072K)] 413038K(1013632K), 0.0003105 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动并发标记步骤
0.526: [CMS-concurrent-mark-start]
0.529: [CMS-concurrent-mark: 0.003/0.003 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]

# 启动预清理步骤，这个阶段会尽可能在重新标记前，处理掉一些在并发标记阶段发生变化的引用关系，从而降低重新标记阶段的停顿时间
# 清理 Eden 区中发生变化的引用（dirty card）
0.529: [CMS-concurrent-preclean-start]
0.530: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动可中断的预清理，这个阶段主要处理 from 和 to 区域对象引用 old gen 的变化，同样也会继续处理 dirty card 的对象引用。这个阶段默认设置的时间是5s，如果执行逻辑超过5s，会自动终止这个阶段，或者当eden区使用内存值小于 CMSScheduleRemarkEdenPenetration，默认 50% 时，也会退出这个阶段。
0.530: [CMS-concurrent-abortable-preclean-start]
0.844: [CMS-concurrent-abortable-preclean: 0.006/0.315 secs] [Times: user=1.34 sys=0.12, real=0.31 secs]

# 重新标记
# 35015K：年轻代当前的使用量；314560K：年轻代的总容量；
0.845: [GC (CMS Final Remark) [YG occupancy: 35015 K (314560 K)]
# Rescan：进行重新标记，耗时 0.0004597 secs
0.845: [Rescan (parallel) , 0.0004597 secs]
# 处理弱引用
0.845: [weak refs processing, 0.0000086 secs]
# 卸载 class
0.845: [class unloading, 0.0004208 secs]
# 清理类级元数据和内部化字符串的符号和字符串表
0.845: [scrub symbol table, 0.0004006 secs]
0.846: [scrub string table, 0.0001479 secs]
# 老年代的使用情况及堆的使用情况
[1 CMS-remark: 677072K(699072K)] 712088K(1013632K), 0.0014893 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动并发清除，任务是清除那些没有标记的无用对象并回收内存
0.846: [CMS-concurrent-sweep-start]
0.847: [CMS-concurrent-sweep: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]

# 启动并发重置，作用是重新设置CMS算法内部的数据结构
0.847: [CMS-concurrent-reset-start]
0.849: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
```









