# 一、简介

CMS垃圾收集器是一款用于**老年代**的，使用复制-清除-整理算法的垃圾收集器。

记住：下面说的所有东西都是在老年代中进行的。

对于 CMS，GC ROOTS 包含：statck、register、gloabl object 和 年轻代。

> 要注意：CMS 是一个老年代的收集器，不是整个堆的垃圾收集器，既然只收集老年代，它必须把当前处于非收集区域的年轻代算作是 GC ROOTS。这跟一般的年轻代 GC 时要把老年代的 Remembered Set 部分算作 GC ROOTS 的道理一样，只不过 HotSpot 没有用 card table 来记录 young -> old 引用，所以就干脆扫描整个年轻代作为 GC ROOTS。

# 二、GC阶段

## 1、初始化标记（STW）

暂停应用程序线程，遍历 GC ROOTS 直接可达的对象并将其压入**标记栈**（mark-stack），标记完之后恢复应用程序线程。

此时，GC ROOTS 直接可达的对象被标记为灰色，其它所有对象默认为白色。

## 2、并发标记

虚拟机分配出若干GC线程去进行并发标记，标记哪些从 GC Roots 可达的对象。

**过程**：弹出标记栈中的对象，递归标记其直接引用的子对象，标记的同时把子对象压入到栈中，重复弹出、压入。。。**直至标记栈为空**。

并发标记结束后，会进入重新标记阶段，此时需要 STW，STW 之前，所有的对象引用都要经过**写屏障**（Write Barrier），确保 STW 之前所有的对象都能统计到。

关于写屏障，下面会说，可以把它用 AOP 的思想去理解它，代码大概长这样：

```c++
void oop_field_store(oop* field, oop new_value) {  
		// 写屏障-写前操作
		pre_write_barrier(field);
    *field = new_value;
    // 写屏障-写后操作
    post_write_barrier(field, new_value);
}

void post_write_barrier(oop* field, oop new_value) {
  // 处于GC并发标记阶段 且 该对象没有被标记（访问）过
  if($gc_phase == GC_CONCURRENT_MARK && !isMarkd(field)) {
      // 记录新引用的对象
    	remark_set.add(new_value);
  }
}
```

这里记录了引用的新值之后，在重新标记阶段就可以对并发标记中错标的对象进行修正，保证不会有错标的对象引用。

在三色标记过程中，这里会把新引用的对象变为灰色，在重新标记阶段会进行扫描。

## 3、重新标记（STW）

重新标记会从根对象（GC ROOTS）开始扫描，扫描所有对象，但是已经标记的对象是不会再遍历一次，

重新从当前的 GC ROOTS 和指针更新的区域出发（mod-union table）再进行一次标记，所以这个过程被叫作重新标记。需要注意的是：**已经标记的对象是不会再遍历一次**，标记线程识别对象在并发阶段已经标记过了，就会跳过该对象。所以重新标记只会遍历那些新增没有标记过的活动对象和其间有指针更新的活动对象，如果指针更新频繁，重新标记很有可能会遍历新生代中的大部分甚至全部对象。所以如果重新标记阶段很慢，可以启动一次YGC，来减少并发标记的工作量减少其停顿时间。

## 4、并发清除

重新标记结束后，应用程序继续运行，此时分出一个处理器去进行垃圾回收工作。

老年代的对象通常是存活时间长，回收比例低，所以采用的回收算法是**标记-清除**。这个阶段 GC 回收线程是遍历整个老年代，遇到没有被标记的对象（垃圾）就清空掉相应的内存块，并加入可分配列表。遇到被标记的对象保持原来的位置不动，只是重置其标记位，用于下一次GC。

## 5、并发重置

Oracle 官方文档中描述这个阶段的工作是：重新调整堆的大小，并为下一次GC做好数据结构支持，比如重置卡表的标位，具体细节有待考证。

# 三、知识点

## 1、卡表

CMS 中一个与 YGC 相关并十分重要的数据结构是：**卡表（card table）**。之所以出现卡表这样的一个数据结构是因为：YGC 时为了标记活动标记对象除了遍历 GC ROOTS 之外，别忘了老年代里也可能会引用新生代对象。所以正常来说还要扫描一次老年代，如果是扫描整个老年代这将会随着堆的增大变得越来越慢，特别是现在内存都越来越大了，所以为了提升性能就引入卡表。

**卡表提升性能的原理**

逻辑上把老年代内存分成一个个大小为 512KB 的卡（card），并且维护一个卡表，用来存储每个卡的标识位，这个标识位用来表示该卡中是否含有老年代到年轻代对象的引用，如果存在引用，就表示这个卡是脏的（dirty card）。

卡表通常使用 byte 数组实现，byte 的值只能取 [0,1] 这两种，每一个 byte 表示老年代中 512KB 的区域，所以老年代被分为了 N 个 512KB 的区域，每个区域用卡表的一个 byte 表示，如果 byte 为 1 表示这 512KB 的区域内含有跨代指针（老年代指向年轻代的指针、引用），就认为这块卡是脏的（dirty card）。

在进行 YGC 的时候，我们便可以不用扫描整个老年代，而是在卡表中寻找脏卡（dirty card），并将脏卡中的对象加入到 YGC 的 GC ROOTS 里，当完成所有脏卡的扫描之后，Java虚拟机便会将所有脏卡的标识位清零（赋值为 0），每次 YGC 结束后都要重置卡表。

这样就避免了扫描整个老年代了，只扫描脏卡即可，使用空间换时间。

## 2、Concurrent Mode Failure

如果 CMS 在清理掉垃圾对象之前，老年代中没有足够的空间存放新产生的对象，就会出现 Concurrent Mode Failure。



## 4、三色标记

实际上三色标记中的色并不只是颜色，而是我们对它的一种叫法，但是实际上他不会用red white 这种东西来定义，而是用例如 0,1,2 这样的东西来定义不同的对象。

其实三色标记就是我们 CMS 在扫描过程中对对象的一种定义。那么具体的定义如下：

- 黑色：1、对象本身及其引用都被扫描过；2、黑色不能直接指向白色；3、不能被回收
- 灰色：1、对象本身被扫描；2、还存在至少一个引用没有被扫描
- 白色：1、没有被扫描；2、扫描结束后被回收

标记过程：

1. 刚开始，所有对象都是白色，没有被扫描
2. 将 GC ROOTS 直接关联的对象标记为灰色
3. 遍历灰色对象的引用，遍历完后，灰色对象本省置为黑色，引用置为灰色
4. 重复步骤3，直到所有的灰色对象被遍历完
5. 结束后，只有黑色和白色对象，黑色存活，白色被回收

这个过程的正确执行的前提是没有其它线程改变对象的引用，但是在 CMS 并发标记的过程中，用户线程仍在运行，因为就会出现漏标或错标。

##### **错标**

如图：假设正在遍历对象B，而此时用户线程执行了 `A.B = null`，切断了 A 到 B 的引用。

![image-20210706173845547](http://snail-resources.oss-cn-beijing.aliyuncs.com/1625564326.575464Yah2dvO8xg.png)

本来执行完`A.B = null`后，B、D、E 都可以被回收，但是由于 B 已经变为灰色了，它仍会被当做存活对象，继续遍历下去。
最终的结果就是本轮GC不会回收B、D、E，留到下次GC时回收，这就是是浮动垃圾。

**漏标**

如图：假设正在遍历对象B，而此时用户线程执行了 `B.D = null`，切断了 B 到 D 的引用，然后又建立了 A 到 D 的引用。 

![image-20210706174131813](http://snail-resources.oss-cn-beijing.aliyuncs.com/1625564492.798998H6Tc2BV34t.png)

由于 A 已经被遍历过了，而 B 又与 D 断开引用了，所以本次标记结束后，D 对象一直是白色，最终是要被回收掉的，如果被回收了，就发生错误了。

可以看到漏标的结果比错标严重的多，浮动垃圾可以下次GC清理，而把不该回收的对象回收掉，将会造成程序运行错误。

漏标只有同时满足一下两个条件才会发生：

1. 灰色对象 断开了 白色对象的引用（直接或间接的引用）；即灰色对象 原来成员变量的引用 发生了变化。
2. 黑色对象 重新引用了 该白色对象；即黑色对象 成员变量增加了 新的引用。

只要打破其中一个条件就可以解决漏标的问题，CMS 选择打破第二个条件，G1 选择打破第一个条件。

5、增量更新

增量更新就是为了解决漏标的情况。

当黑色指向白色的引用被建立时，就将这个新的引用关系记录下来，等扫描结束后，再以这些记录中的黑色对象为根，重新扫描一次。相当于黑色对象一旦建立了指向白色对象的引用，就会把白色对象变为灰色对象，然后递归扫描。





# 四、缺点

1. **内存碎片**（原因是采用了标记-清除算法）
2. **对 CPU 资源敏感**（原因是并发时和用户线程一起抢占 CPU）
3. **浮动垃圾**：在并发标记阶段产生了新垃圾不会被及时回收，而是只能等到下一次GC

然后我产生了一个疑问：既然重新标记可以修正并发标记阶段的变动，那么为何还有浮动垃圾问题？

由于标记阶段是从 GC Roots 开始标记可达对象，那么在并发标记阶段可能产生两种变动：

1. 本来可达的对象，变得不可达了。（浮动垃圾）
2. 本来不可达的内存，变得可达了。

浮动垃圾是可容忍的问题，而不是错误。那么为什么重新标记阶段不处理第一种变动呢？也许是由可达变为不可达这样的变化需要重新从 GC Roots 开始遍历，相当于再完成一次初始标记和并发标记的工作，这样不仅前两个阶段变成多余的，浪费了开销浪费，还会大大增加重新标记阶段的开销，所带来的暂停时间是追求低延迟的CMS所不能容忍的。

# 四、日志解读

```
# 年轻代 GC，使用 ParNew
0.210 [GC (Allocation Failure) [ParNew: 279616K->34942K(314560K), 0.0246537 secs] 279616K->79707K(1013632K), 0.0246999 secs] [Times: user=0.06 sys=0.09, real=0.03 secs]

# 老年代 GC

# 初始计标记，速度很快只用了3.1毫秒
# 372071K：老年代的使用量；699072K：老年代的总容量；413038K：堆的使用量；1013632K：整个堆的容量；0.0003105 secs：耗时
0.526: [GC (CMS Initial Mark) [1 CMS-initial-mark: 372071K(699072K)] 413038K(1013632K), 0.0003105 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动并发标记步骤
0.526: [CMS-concurrent-mark-start]
0.529: [CMS-concurrent-mark: 0.003/0.003 secs] [Times: user=0.00 sys=0.01, real=0.01 secs]

# 启动预清理步骤，这个阶段会尽可能在重新标记前，处理掉一些在并发标记阶段发生变化的引用关系，从而降低重新标记阶段的停顿时间
# 清理 Eden 区中发生变化的引用（dirty card）
0.529: [CMS-concurrent-preclean-start]
0.530: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动可中断的预清理，这个阶段主要处理 from 和 to 区域对象引用 old gen 的变化，同样也会继续处理 dirty card 的对象引用。这个阶段默认设置的时间是5s，如果执行逻辑超过5s，会自动终止这个阶段，或者当eden区使用内存值小于 CMSScheduleRemarkEdenPenetration，默认 50% 时，也会退出这个阶段。
0.530: [CMS-concurrent-abortable-preclean-start]
0.844: [CMS-concurrent-abortable-preclean: 0.006/0.315 secs] [Times: user=1.34 sys=0.12, real=0.31 secs]

# 重新标记
# 35015K：年轻代当前的使用量；314560K：年轻代的总容量；
0.845: [GC (CMS Final Remark) [YG occupancy: 35015 K (314560 K)]
# Rescan：进行重新标记，耗时 0.0004597 secs
0.845: [Rescan (parallel) , 0.0004597 secs]
# 处理弱引用
0.845: [weak refs processing, 0.0000086 secs]
# 卸载 class
0.845: [class unloading, 0.0004208 secs]
# 清理类级元数据和内部化字符串的符号和字符串表
0.845: [scrub symbol table, 0.0004006 secs]
0.846: [scrub string table, 0.0001479 secs]
# 老年代的使用情况及堆的使用情况
[1 CMS-remark: 677072K(699072K)] 712088K(1013632K), 0.0014893 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 启动并发清除，任务是清除那些没有标记的无用对象并回收内存
0.846: [CMS-concurrent-sweep-start]
0.847: [CMS-concurrent-sweep: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]

# 启动并发重置，作用是重新设置CMS算法内部的数据结构
0.847: [CMS-concurrent-reset-start]
0.849: [CMS-concurrent-reset: 0.001/0.001 secs] [Times: user=0.01 sys=0.00, real=0.00 secs]
```









