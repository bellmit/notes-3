# 一、分配速率

分配速率表示单位时间内分配的内存量，通常使用 MB/sec 作为单位，上一次垃圾收集之后，与下一次GC开始之前的年轻代使用量，两者的差值除以时间就是分配速度。

分配速率过高会严重影响程序性能，在 JVM 中可能导致巨大的 GC 开销。

- 正常系统：分配速率较低 约等于 回收速率 -> 健康
- 内存泄漏：分配速率 持续大于 回收速率 -> OOM
- 性能劣化：分配速率很高 约等于 回收速度 -> 亚健康

通过分析 GC 日志可以获取内存的分配速率，例如：

```
0.152: [GC (Allocation Failure) [PSYoungGen: 131584K->21484K(153088K)] 131584K->43183K(502784K), 0.0132600 secs] [Times: user=0.02 sys=0.05, real=0.01 secs]

0.182: [GC (Allocation Failure) [PSYoungGen: 153068K->21495K(153088K)] 174767K->79780K(502784K), 0.0183188 secs] [Times: user=0.03 sys=0.07, real=0.02 secs]

0.215: [GC (Allocation Failure) [PSYoungGen: 153079K->21490K(153088K)] 211364K->122251K(502784K), 0.0153485 secs] [Times: user=0.03 sys=0.06, real=0.02 secs]
```

使用 -XX:+PrintGCTimeStamps 可以打印自虚拟机启动后经过了多长时间产生了 GC。

解读：

- 虚拟机启动后的 0.152 秒发生了 Young GC，此时年轻代已经分配了 131584KB 的对象，所有在这段时间分配速率为：131584 / 1024 / 0.152 = 845.39 MB/sec。然后年轻代回收了 131584 - 21484 = 110100KB 的内存，整个堆内存回收了 131584 - 43183 = 88401KB 的内存，中间差了 110100 - 88401 = 21699KB 的内存，说明这 21699KB 的数据被晋升到老年代了。
- 在 0.182 秒出发生了 Young GC，分配速率为 (153068 - 21484) / 1024 / (0.182 - 0.152) = 4283.33 MB/sec
- 在 0.215 秒出发生了 Young GC，分配速率为 (153079 - 21495) / 1024 / (0.215 - 0.182) = 3893.93 MB/sec

# 二、提升速率

提升速率用于衡量单位时间内从年轻代晋升到老年代的数据量，一般使用 MB/sec 作为单位。

JVM 会将长时间存活的对象从年轻代提升到老年代，根据分代假设，可能存在一种情况，老年代中不仅有存活时间长的对象，也可能有存活时间短的对象，这就是过早提升：对象存活时间还不够长的时候就被提升到了老年代。

major GC 不是为了频繁回收而设计的，但 major GC 现在也要清理掉这些声明短暂的对象，就会导致 GC 暂停时间过长，这会严重影响系统的吞吐量。

计算公式：（年轻代的回收量 - 堆内存的回收量）/ 1024 / 时间

比如： 0.152 秒时计算出 21699KM 的数据晋升到了老年代，则晋升速率为：21699 / 1024 / 0.152 = 139.41 MB/sec。

使用 `-XX:MaxTenuringThreshold=15` 参数进行设置晋升年龄。
